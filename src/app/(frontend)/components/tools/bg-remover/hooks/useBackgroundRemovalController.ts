import { useState, useEffect, useRef, useCallback } from 'react'
import type { ExtendedImageJob, WorkerInitializationPhase } from './types'
import {
  useSegmentationController,
  usePreprocessingController,
  usePostprocessingController,
} from './'
import JSZip from 'jszip'
import { isWebGLSupported, isWebGPUSupported } from '@/frontend/utils/browserFeatures'

const MAX_PREPROCESSING_WORKERS = 2
const MAX_SEGMENTATION_WORKERS = 4
const MAX_POSTPROCESSING_WORKERS = 2

/**
 * @hook useBackgroundRemovalController
 * @description
 * Main controller hook for orchestrating the entire background removal process. This hook serves as the central
 * management unit for the multi-stage image processing pipeline. It coordinates Web Workers for computationally
 * intensive tasks, manages job queues for each processing stage, handles UI state updates (e.g., loading
 * indicators, error messages, image lists), and oversees the lifecycle of workers and associated resources
 * to prevent memory leaks.
 *
 * The background removal process is divided into three main stages:
 * 1.  **Preprocessing**: Managed by `usePreprocessingController`. This stage involves preparing images for the
 *     segmentation model. Tasks include resizing images to the model's expected input dimensions and converting
 *     them into a suitable format. Workers are used to offload this from the main thread.
 * 2.  **Segmentation**: Managed by `useSegmentationController`. This is the core AI-driven stage where a
 *     machine learning model (e.g., a deep learning segmentation model) analyzes the preprocessed image
 *     to identify the foreground and generate a mask. This stage is computationally expensive and relies
 *     heavily on Web Workers. The model itself is loaded and managed by these workers.
 * 3.  **Mask Application (Postprocessing)**: Managed by `usePostprocessingController`. In this final stage,
 *     the mask generated by the segmentation stage is applied to the original (or preprocessed) image.
 *     This typically involves operations like alpha blending or compositing to effectively remove the background,
 *     resulting in an image with a transparent background or a specified background color. This stage also utilizes Web Workers.
 *
 * The hook maintains several queues: `preprocessingQueueRef`, `segmentationQueueRef`, and
 * `postprocessingQueueRef` to manage the flow of image jobs through these stages. It uses state
 * variables (`triggerPreprocessingQueue`, `triggerSegmentationQueue`, `triggerPostprocessingQueue`)
 * to signal when a queue should be processed.
 *
 * State management includes:
 * - `modelLoading`, `modelLoaded`: Tracking the state of the segmentation model.
 * - `imageList`: An array of `ExtendedImageJob` objects, representing the state of each image.
 * - `overallError`: Stores any critical error messages.
 * - `isBatchActive`: Indicates if a batch processing operation is currently underway.
 * - `initializationPhase`: Tracks the initialization status of the workers, especially for model loading.
 * - `backgroundColor`: The background color to apply to processed images (null for transparent).
 *
 * Callbacks like `handleFileChange`, `handleStartBatchProcess`, `downloadImage`, `createAndDownloadZip`,
 * `clearAllJobs`, and `removeJob` provide the interface for interacting with the background removal system.
 *
 * Derived states like `hasPendingOrQueuedJobs`, `remainingJobCount`, and active job counts for each
 * worker pool are also provided for UI feedback.
 */
export const useBackgroundRemovalController = (
  backgroundColor: string | null = null,
  backgroundImageUrl: string | null = null,
  backgroundImageAlpha: number = 1.0,
  backgroundColorAlpha: number = 1.0,
) => {
  const [modelLoading, setModelLoading] = useState<boolean>(false)
  const [modelLoaded, setModelLoaded] = useState<boolean>(false)
  const [imageList, setImageList] = useState<ExtendedImageJob[]>([])
  const [overallError, setOverallError] = useState<string | null>(null)
  const [isBatchActive, setIsBatchActive] = useState<boolean>(false)
  const [triggerSegmentationQueue, setTriggerSegmentationQueue] = useState<number>(0)
  const [triggerPreprocessingQueue, setTriggerPreprocessingQueue] = useState<number>(0)
  const [triggerPostprocessingQueue, setTriggerMaskApplicationQueue] = useState<number>(0)

  const [initializationPhase, setInitializationPhase] = useState<WorkerInitializationPhase>('idle')

  const [webGLSupported, setWebGLSupported] = useState<boolean>(true)
  const [webGPUSupported, setWebGPUSupported] = useState<boolean>(true)
  const [compatibilityChecked, setCompatibilityChecked] = useState<boolean>(false)

  // Refs for state values to stabilize callbacks passed to sub-hooks
  // These refs ensure that functions passed to child hooks (like processNextFor...)
  // do not become stale due to closure over state that changes frequently.
  const modelLoadedRef = useRef(modelLoaded)
  const modelLoadingRef = useRef(modelLoading)
  const isBatchActiveRef = useRef(isBatchActive)
  const imageListRef = useRef(imageList)
  const initializationPhaseRef = useRef(initializationPhase)
  const overallErrorRef = useRef(overallError)

  // Add a ref to track if we're already trying to process the mask application queue
  const [isMaskQueueBeingProcessed, setIsMaskQueueBeingProcessed] = useState<boolean>(false)

  useEffect(() => {
    modelLoadedRef.current = modelLoaded
  }, [modelLoaded])
  useEffect(() => {
    modelLoadingRef.current = modelLoading
  }, [modelLoading])
  useEffect(() => {
    isBatchActiveRef.current = isBatchActive
  }, [isBatchActive])
  useEffect(() => {
    imageListRef.current = imageList
  }, [imageList])
  useEffect(() => {
    initializationPhaseRef.current = initializationPhase
  }, [initializationPhase])
  useEffect(() => {
    overallErrorRef.current = overallError
  }, [overallError])

  useEffect(() => {
    const checkCompatibility = async () => {
      const glSupport = isWebGLSupported()
      const gpuSupport = await isWebGPUSupported()
      setWebGLSupported(glSupport)
      setWebGPUSupported(gpuSupport)
      setCompatibilityChecked(true)
    }
    checkCompatibility()
  }, [])

  const commonHookOptions = {
    imageListRef,
    isBatchActiveRef,
    overallErrorRef,
    setImageList,
    setOverallError,
  }

  const {
    postprocessingQueueRef,
    processNextForMaskApplication,
    cleanupMaskApplicationWorkers,
    postprocessingWorkerJobAssignments,
    maskApplicationWorkerInitializationStatus,
    maskApplicationWorkerReadyStatus,
  } = usePostprocessingController({
    ...commonHookOptions,
    setTriggerMaskApplicationQueue,
    setTriggerProcessQueue: setTriggerSegmentationQueue, // Next stage trigger
    MAX_MASK_APPLICATION_WORKERS: MAX_POSTPROCESSING_WORKERS,
    isMaskQueueBeingProcessed,
    setIsMaskQueueBeingProcessed,
  })

  // Store segmentation controller return values for use in the BackgroundRemover component
  const segmentationController = useSegmentationController({
    ...commonHookOptions,
    modelLoadedRef,
    modelLoadingRef,
    initializationPhase,
    setModelLoading,
    setModelLoaded,
    setInitializationPhase,
    setTriggerProcessQueue: setTriggerSegmentationQueue, // Self trigger for queue processing
    setTriggerMaskApplicationQueue, // Next stage trigger
    postprocessingQueueRef,
    MAX_SEGMENTATION_WORKERS,
  })

  // Destructure and rename segmentation controller values for use in this hook
  const {
    segmentationQueueRef,
    processNextForSegmentation,
    cleanupSegmentationWorkers,
    segmentationWorkerJobAssignments,
    segmentationWorkerInitializationStatus,
  } = segmentationController

  const {
    preprocessingQueueRef,
    processNextForPreprocessing,
    cleanupPreprocessingWorkers,
    preprocessingWorkerJobAssignments,
    preprocessingWorkerInitializationStatus,
    preprocessingWorkerReadyStatus,
  } = usePreprocessingController({
    ...commonHookOptions,
    modelLoadedRef,
    segmentationQueueRef,
    setTriggerPreprocessingQueue, // Self trigger for queue processing
    setTriggerProcessQueue: setTriggerSegmentationQueue, // Next stage trigger
    MAX_PREPROCESSING_WORKERS,
  })

  // Cleanup effect: Runs on component unmount.
  // Terminates all worker threads and revokes Object URLs to prevent memory leaks.
  useEffect(() => {
    return () => {
      // Component unmounting: Terminate all workers and cleaning up resources.
      cleanupSegmentationWorkers()
      cleanupPreprocessingWorkers()
      cleanupMaskApplicationWorkers()

      imageListRef.current.forEach((job) => {
        if (job.originalBlobUrl) URL.revokeObjectURL(job.originalBlobUrl)
        if (job.processedImageUrl) URL.revokeObjectURL(job.processedImageUrl)
      })

      setInitializationPhase('idle')
      setModelLoading(false)
      setModelLoaded(false)
      setOverallError(null)
    }
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Effect for triggering the preprocessing queue.
  // Runs when `triggerPreprocessingQueue` changes or `processNextForPreprocessing` callback updates.
  useEffect(() => {
    console.log(
      `[MainThread-BgCtrl] Preprocessing queue triggered. Batch active: ${isBatchActiveRef.current}, Queue length: ${preprocessingQueueRef.current.length}`,
    )

    if (isBatchActiveRef.current) {
      console.log(`[MainThread-BgCtrl] Processing preprocessing queue`)

      // Debug: Print the detailed state of the preprocessing workers and jobs
      const workerInitStatus = preprocessingWorkerInitializationStatus.current
        .map((status, index) => {
          const readyStatus = preprocessingWorkerReadyStatus?.current[index] ? 'Ready' : 'Not Ready'
          return `Worker ${index}: ${status} (${readyStatus})`
        })
        .join(', ')

      const workerAssignments = Array.from(preprocessingWorkerJobAssignments.current.entries())
        .map(([index, jobId]) => `Worker ${index}: ${jobId || 'idle'}`)
        .join(', ')

      const queueContent =
        preprocessingQueueRef.current.length > 0
          ? `Queue jobs: ${preprocessingQueueRef.current.join(', ')}`
          : 'Queue empty'

      console.log(`[MainThread-BgCtrl] Preprocessing System State:
        Worker Init Status: ${workerInitStatus}
        Worker Assignments: ${workerAssignments}
        ${queueContent}
      `)

      processNextForPreprocessing()
    }
  }, [
    triggerPreprocessingQueue,
    processNextForPreprocessing,
    preprocessingQueueRef,
    preprocessingWorkerReadyStatus,
    preprocessingWorkerInitializationStatus,
    preprocessingWorkerJobAssignments,
    postprocessingQueueRef,
  ])

  // Effect for triggering the segmentation queue and managing batch completion/re-queueing logic.
  // Runs when `triggerSegmentationQueue` changes or `processNextForSegmentation` callback updates.
  useEffect(
    () => {
      console.log(
        `[MainThread-BgCtrl] Segmentation queue triggered. Model loaded: ${modelLoadedRef.current}, Batch active: ${isBatchActiveRef.current}, Queue length: ${segmentationQueueRef.current.length}`,
      )

      // Only process if there's something to process
      if (
        modelLoadedRef.current &&
        isBatchActiveRef.current &&
        segmentationQueueRef.current.length > 0
      ) {
        console.log(`[MainThread-BgCtrl] Processing segmentation queue`)
        processNextForSegmentation()
      }

      // Only trigger mask application queue if not already being processed
      // to avoid the infinite loop
      if (
        isBatchActiveRef.current &&
        postprocessingQueueRef.current.length > 0 &&
        !isMaskQueueBeingProcessed
      ) {
        console.log(
          `[MainThread-BgCtrl] Found ${postprocessingQueueRef.current.length} items in mask application queue, triggering processing`,
        )
        setIsMaskQueueBeingProcessed(true)
        // Use setTimeout to break the immediate synchronous update cycle
        setTimeout(() => {
          setTriggerMaskApplicationQueue((c) => c + 1)
        }, 50)
      }

      // Core batch management logic:
      // 1. Check if the entire batch is completed.
      //    - Batch is active.
      //    - All processing queues (preprocessing, segmentation, mask application) are empty.
      //    - All worker job assignments are null (no workers are currently busy).
      //    - All jobs in the imageList are either 'completed' or 'error'.
      //    If all conditions met, set isBatchActive to false.
      if (
        isBatchActiveRef.current &&
        preprocessingQueueRef.current.length === 0 &&
        segmentationQueueRef.current.length === 0 &&
        postprocessingQueueRef.current.length === 0 &&
        Array.from(preprocessingWorkerJobAssignments.current.values()).every((j) => j === null) &&
        Array.from(segmentationWorkerJobAssignments.current.values()).every((j) => j === null) &&
        Array.from(postprocessingWorkerJobAssignments.current.values()).every((j) => j === null) &&
        imageListRef.current.every((job) => job.status === 'completed' || job.status === 'error')
      ) {
        setIsBatchActive(false)
        // 2. Handle re-queueing for stuck jobs if batch is not complete but queues/workers are idle.
        //    - Batch is active.
        //    - All processing queues are empty.
        //    - All worker job assignments are null.
        //    - BUT some jobs in imageList are not 'completed' or 'error' (i.e., they are stuck in an intermediate state).
        //    This can happen due to race conditions or if a worker failed silently.
        //    Identify such jobs and re-add them to their respective queues to attempt reprocessing.
      } else if (
        isBatchActiveRef.current &&
        preprocessingQueueRef.current.length === 0 &&
        segmentationQueueRef.current.length === 0 &&
        postprocessingQueueRef.current.length === 0 &&
        Array.from(preprocessingWorkerJobAssignments.current.values()).every((j) => j === null) &&
        Array.from(segmentationWorkerJobAssignments.current.values()).every((j) => j === null) &&
        Array.from(postprocessingWorkerJobAssignments.current.values()).every((j) => j === null) &&
        imageListRef.current.some((job) => job.status !== 'completed' && job.status !== 'error')
      ) {
        // Find jobs stuck in pending states and re-queue them.
        console.log('[MainThread-BgCtrl] Re-queueing logic: Checking for stuck jobs.')
        const jobsToRequeueForPreprocessing = imageListRef.current
          .filter((j) => j.status === 'pending_preprocessing')
          .map((j) => j.id)
        const jobsToRequeueForSegmentation = imageListRef.current
          .filter(
            (j) =>
              (j.status === 'pending_segmentation' || j.status === 'queued') &&
              j.preprocessedImageUrl, // Ensure preprocessing is done
          )
          .map((j) => j.id)
        const jobsToRequeueForMaskApplication = imageListRef.current
          .filter(
            (j) =>
              j.status === 'pending_postprocessing' &&
              j.segmentationResult && // Ensure segmentation is done
              j.preprocessedImageUrl, // Ensure preprocessing is done
          )
          .map((j) => j.id)

        // Only update queues and trigger processing if there are actually jobs to requeue
        let needToTriggerProcessing = false

        if (jobsToRequeueForPreprocessing.length > 0) {
          const newJobs = jobsToRequeueForPreprocessing.filter(
            (id) => !preprocessingQueueRef.current.includes(id), // Avoid duplicates in queue
          )
          if (newJobs.length > 0) {
            console.log('[MainThread-BgCtrl] Re-queueing for preprocessing:', newJobs)
            preprocessingQueueRef.current.push(...newJobs)
            needToTriggerProcessing = true
          }
        }

        if (jobsToRequeueForSegmentation.length > 0 && modelLoadedRef.current) {
          const newJobs = jobsToRequeueForSegmentation.filter(
            (id) => !segmentationQueueRef.current.includes(id), // Avoid duplicates in queue
          )
          if (newJobs.length > 0) {
            console.log('[MainThread-BgCtrl] Re-queueing for segmentation:', newJobs)
            segmentationQueueRef.current.push(...newJobs)
            needToTriggerProcessing = true
          }
        }

        if (jobsToRequeueForMaskApplication.length > 0) {
          const newJobs = jobsToRequeueForMaskApplication.filter(
            (id) => !postprocessingQueueRef.current.includes(id), // Avoid duplicates in queue
          )
          if (newJobs.length > 0) {
            console.log('[MainThread-BgCtrl] Re-queueing for mask application:', newJobs)
            postprocessingQueueRef.current.push(...newJobs)
            needToTriggerProcessing = true
          }
        }

        // Only trigger processing if we actually added new jobs to any queue
        if (needToTriggerProcessing) {
          console.log('[MainThread-BgCtrl] Triggering processing for re-queued jobs.')
          if (jobsToRequeueForPreprocessing.length > 0) {
            setTriggerPreprocessingQueue((c) => c + 1)
          }
          if (jobsToRequeueForSegmentation.length > 0 && modelLoadedRef.current) {
            setTriggerSegmentationQueue((c) => c + 1)
          }
          if (jobsToRequeueForMaskApplication.length > 0) {
            setTriggerMaskApplicationQueue((c) => c + 1)
          }
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      triggerSegmentationQueue,
      processNextForSegmentation,
      setIsBatchActive,
      setTriggerPreprocessingQueue,
      setTriggerSegmentationQueue,
      setTriggerMaskApplicationQueue,
      modelLoadedRef,
      isBatchActiveRef,
      segmentationQueueRef,
      preprocessingQueueRef,
      postprocessingQueueRef,
      isMaskQueueBeingProcessed,
    ],
  )

  // Effect for triggering the mask application queue.
  // Runs when `triggerPostprocessingQueue` changes or `processNextForMaskApplication` callback updates.
  useEffect(() => {
    if (isBatchActiveRef.current) {
      console.log(
        `[MainThread-BgCtrl] Mask application queue triggered. Queue length: ${postprocessingQueueRef.current.length}`,
      )

      // Debug: Print the detailed state of the mask application workers and jobs
      const workerInitStatus = maskApplicationWorkerInitializationStatus.current
        .map((status, index) => {
          const readyStatus = maskApplicationWorkerReadyStatus?.current[index]
            ? 'Ready'
            : 'Not Ready'
          return `Worker ${index}: ${status} (${readyStatus})`
        })
        .join(', ')

      const workerAssignments = Array.from(postprocessingWorkerJobAssignments.current.entries())
        .map(([index, jobId]) => `Worker ${index}: ${jobId || 'idle'}`)
        .join(', ')

      const queueContent =
        postprocessingQueueRef.current.length > 0
          ? `Queue jobs: ${postprocessingQueueRef.current.join(', ')}`
          : 'Queue empty'

      console.log(`[MainThread-BgCtrl] Mask Application System State:
        Worker Init Status: ${workerInitStatus}
        Worker Assignments: ${workerAssignments}
        ${queueContent}
      `)

      // Check if any workers are available before attempting to process
      const anyPostProcessingWorkersReady = maskApplicationWorkerReadyStatus?.current.some(
        (status) => status === true,
      )

      if (anyPostProcessingWorkersReady) {
        processNextForMaskApplication()
      } else {
        console.log(
          `[MainThread-BgCtrl] No postprocessing workers are ready, cannot process queue now. Will retry later.`,
        )

        // If processing is not possible now, reset the flag to allow retrying
        setIsMaskQueueBeingProcessed(false)
      }
    } else {
      // Reset flag when batch is not active
      setIsMaskQueueBeingProcessed(false)
    }
  }, [
    triggerPostprocessingQueue,
    processNextForMaskApplication,
    isBatchActiveRef,
    postprocessingQueueRef,
    maskApplicationWorkerInitializationStatus,
    maskApplicationWorkerReadyStatus,
    postprocessingWorkerJobAssignments,
  ])

  /**
   * @function handleFileChange
   * @description Callback for file input change events.
   * Creates new ExtendedImageJob objects for each selected file,
   * generates blob URLs for previews, and adds them to the imageList.
   */
  const handleFileChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const files = event.target.files
      if (!files || files.length === 0) return

      const newJobs: ExtendedImageJob[] = []
      for (let i = 0; i < files.length; i++) {
        const file = files[i]
        const job: ExtendedImageJob = {
          id: crypto.randomUUID(),
          file,
          name: file.name,
          originalBlobUrl: URL.createObjectURL(file),
          status: 'pending_preprocessing', // Initial status for new jobs
          backgroundColor, // Include the current background color setting
          backgroundColorAlpha, // Include the current background color alpha setting
          backgroundImageUrl, // Include the current background image setting
          backgroundImageAlpha, // Include the current background image alpha setting
        }
        newJobs.push(job)
      }

      // Initiate model loading if this is the first file upload and model isn't already loading or loaded.
      if (newJobs.length > 0 && imageListRef.current.length === 0) {
        if (
          !modelLoadedRef.current &&
          !modelLoadingRef.current &&
          initializationPhaseRef.current === 'idle'
        ) {
          console.log(
            '[MainThread-BgCtrl] First file(s) uploaded. Initiating model loading by setting phase to initializing_first.',
          )
          setInitializationPhase('initializing_first')
        }
      }

      setImageList((prevList) => [...prevList, ...newJobs])
      setOverallError(null) // Clear any previous overall errors
      event.target.value = '' // Allow selecting the same file again
    },
    [
      setImageList,
      setOverallError,
      setInitializationPhase,
      backgroundColor,
      backgroundColorAlpha,
      backgroundImageUrl,
      backgroundImageAlpha,
    ], // modelLoadedRef, modelLoadingRef, initializationPhaseRef, imageListRef are refs and stable
  )

  /**
   * @function handleStartBatchProcess
   * @description Initiates the background removal batch process.
   * - Sets the batch to active.
   * - Initializes segmentation workers if they haven't been (for model loading).
   * - Populates the initial preprocessing queue with jobs in 'pending_preprocessing' status.
   * - Populates segmentation and mask application queues if jobs are already in those respective pending states
   *   (e.g. if a previous batch was interrupted or files were added mid-process).
   * - Triggers the processing for each queue if conditions are met (e.g., model loaded for segmentation).
   */
  const handleStartBatchProcess = useCallback(() => {
    console.log(
      `[MainThread-BgCtrl] Starting batch process. Phase: ${initializationPhaseRef.current}, Model loaded: ${modelLoadedRef.current}, Model loading: ${modelLoadingRef.current}`,
    )

    // If model isn't loaded or loading, and workers are idle, start initialization.
    // This primarily triggers the segmentation workers to load the ML model.
    if (
      initializationPhaseRef.current === 'idle' &&
      !modelLoadedRef.current &&
      !modelLoadingRef.current
    ) {
      console.log(
        `[MainThread-BgCtrl] Initiating model loading - setting phase to initializing_first`,
      )
      setInitializationPhase('initializing_first')
    }

    // Check if any preprocessing workers are available and ready.
    const anyPreprocessingWorkerReady = preprocessingWorkerInitializationStatus.current.some(
      (s, i) => s === 'success' && preprocessingWorkerReadyStatus?.current[i] === true,
    )

    const allPreprocessingWorkersAttempted =
      preprocessingWorkerInitializationStatus.current.length === MAX_PREPROCESSING_WORKERS &&
      preprocessingWorkerInitializationStatus.current.every((s) => s !== 'pending')

    if (!anyPreprocessingWorkerReady && allPreprocessingWorkersAttempted) {
      setOverallError('Cannot start: No preprocessing workers are available or ready.')
      return
    }

    // Identify jobs that are ready to be processed.
    const processableJobs = imageListRef.current.filter(
      (job) =>
        job.status === 'pending_preprocessing' ||
        ((job.status === 'pending_segmentation' || job.status === 'queued') &&
          job.preprocessedImageUrl) || // Ready for segmentation if preprocessed
        (job.status === 'pending_postprocessing' &&
          job.preprocessedImageUrl &&
          job.segmentationResult), // Ready for postprocessing if preprocessed and segmented
    )

    if (processableJobs.length === 0) {
      // No pending or processable images to start a new batch.
      console.log(
        '[MainThread-BgCtrl] handleStartBatchProcess: No processable jobs found. Exiting.',
      )
      return
    }

    setIsBatchActive(true) // Mark the batch as active

    // Populate preprocessing queue
    const jobsForPreprocessing = imageListRef.current.filter(
      (job) => job.status === 'pending_preprocessing',
    )
    console.log(`[MainThread-BgCtrl] Found ${jobsForPreprocessing.length} jobs for preprocessing`)

    if (jobsForPreprocessing.length > 0) {
      // Create a new array with unique job IDs to ensure no duplicates
      const jobIdsToAdd = jobsForPreprocessing.map((job) => job.id)
      console.log(`[MainThread-BgCtrl] Adding job IDs to preprocessing queue:`, jobIdsToAdd)

      // Update the queue with the unique job IDs
      preprocessingQueueRef.current = [
        ...new Set([...preprocessingQueueRef.current, ...jobIdsToAdd]),
      ]

      console.log(
        `[MainThread-BgCtrl] Updated preprocessing queue length: ${preprocessingQueueRef.current.length}`,
      )
      console.log(
        `[MainThread-BgCtrl] Worker status: anyReady=${anyPreprocessingWorkerReady}, allAttempted=${allPreprocessingWorkersAttempted}`,
      )

      // Trigger preprocessing only if workers are available or not all have attempted initialization yet.
      if (anyPreprocessingWorkerReady || !allPreprocessingWorkersAttempted) {
        console.log(`[MainThread-BgCtrl] Triggering preprocessing queue processing`)
        // Force a slight delay to ensure workers are fully initialized
        setTimeout(() => {
          setTriggerPreprocessingQueue((c) => c + 1)
        }, 100)
      }
    }

    // Populate segmentation queue
    const jobsForSegmentation = imageListRef.current.filter(
      (job) =>
        (job.status === 'pending_segmentation' || job.status === 'queued') &&
        job.preprocessedImageUrl,
    )
    if (jobsForSegmentation.length > 0) {
      segmentationQueueRef.current = [
        ...new Set([...segmentationQueueRef.current, ...jobsForSegmentation.map((job) => job.id)]),
      ]
      // Update job status to 'queued' if model is loaded, otherwise keep as 'pending_segmentation'
      setImageList((prevList) =>
        prevList.map((job) => {
          if (jobsForSegmentation.find((sj) => sj.id === job.id)) {
            return {
              ...job,
              status: modelLoadedRef.current ? 'queued' : 'pending_segmentation',
            } as ExtendedImageJob
          }
          return job
        }),
      )
      if (modelLoadedRef.current) setTriggerSegmentationQueue((c) => c + 1) // Trigger if model is ready
    }

    // Populate mask application queue
    const jobsForMaskApplication = imageListRef.current.filter(
      (job) =>
        job.status === 'pending_postprocessing' &&
        job.preprocessedImageUrl &&
        job.segmentationResult,
    )
    if (jobsForMaskApplication.length > 0) {
      postprocessingQueueRef.current = [
        ...new Set([
          ...postprocessingQueueRef.current,
          ...jobsForMaskApplication.map((job) => job.id),
        ]),
      ]
      setTriggerMaskApplicationQueue((c) => c + 1) // Always trigger if jobs exist for this stage
    }
  }, [
    setInitializationPhase,
    setOverallError,
    setIsBatchActive,
    setImageList,
    preprocessingWorkerInitializationStatus, // Dependency for checking worker status
    // Refs to queues are stable, direct mutation is fine here and doesn't need to be a dependency for useCallback
    // but the trigger functions are needed to actually start processing after queue manipulation.
    setTriggerPreprocessingQueue,
    setTriggerSegmentationQueue,
    setTriggerMaskApplicationQueue,
    postprocessingQueueRef,
    preprocessingWorkerReadyStatus,
    segmentationQueueRef,
    preprocessingQueueRef,
  ])

  /**
   * @function downloadImage
   * @description Triggers a browser download for the given image URL and filename.
   */
  const downloadImage = useCallback((imageUrl?: string, fileName?: string) => {
    if (!imageUrl || !fileName) return
    const link = document.createElement('a')
    link.href = imageUrl
    link.download = `bg-removed-${fileName}` // Prepend prefix to downloaded filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }, [])

  /**
   * @function getBlobFromUrl
   * @description Retrieves a Blob from a URL (blob URL or data URL)
   */
  const getBlobFromUrl = useCallback(async (url: string): Promise<Blob> => {
    // If it's a blob URL or data URL
    if (url.startsWith('blob:') || url.startsWith('data:')) {
      // For blob URLs, fetch the blob directly
      if (url.startsWith('blob:')) {
        const response = await fetch(url)
        return await response.blob()
      }

      // For data URLs, convert to blob
      const parts = url.split(';base64,')
      if (parts.length === 2) {
        const contentType = parts[0].split(':')[1]
        const raw = window.atob(parts[1])
        const uInt8Array = new Uint8Array(raw.length)

        for (let i = 0; i < raw.length; i++) {
          uInt8Array[i] = raw.charCodeAt(i)
        }

        return new Blob([uInt8Array], { type: contentType })
      }
    }

    throw new Error('Unsupported URL format')
  }, [])

  /**
   * @function createAndDownloadZip
   * @description Creates a ZIP file from specified images and triggers its download
   */
  const createAndDownloadZip = useCallback(
    async (imagesToZip: ExtendedImageJob[], zipFilename = 'bg-removed-images.zip') => {
      if (imagesToZip.length === 0) {
        console.warn('No images to download')
        return
      }

      try {
        const zip = new JSZip()
        let successCount = 0
        let errorCount = 0

        // Add each image to the ZIP file
        for (const job of imagesToZip) {
          if (!job.processedImageUrl || job.status !== 'completed') continue

          const filename = `bg-removed-${job.name}`

          try {
            // Get blob from URL for better compression
            const blob = await getBlobFromUrl(job.processedImageUrl)

            // Add the file to the ZIP
            zip.file(filename, blob)
            successCount++
          } catch (error) {
            console.error(`Error adding ${filename} to ZIP:`, error)
            errorCount++
            // Skip this file but continue with others
          }
        }

        // If no files were successfully added, show error
        if (successCount === 0) {
          throw new Error('Failed to add any images to the ZIP file')
        }

        // Generate the ZIP file
        const zipBlob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 },
        })

        // Create a download link for the ZIP
        const zipUrl = URL.createObjectURL(zipBlob)
        const a = document.createElement('a')
        a.href = zipUrl
        a.download = zipFilename
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)

        // Clean up
        URL.revokeObjectURL(zipUrl)

        // Report any errors
        if (errorCount > 0) {
          console.warn(`${errorCount} files could not be added to the ZIP`)
        }

        return successCount
      } catch (error) {
        console.error('Error creating ZIP file:', error)
        alert('Error creating ZIP file. Some images may download individually.')

        // Fallback to individual downloads if zipping fails completely
        imagesToZip.forEach((job, index) => {
          if (job.processedImageUrl) {
            setTimeout(() => {
              downloadImage(job.processedImageUrl, job.name)
            }, index * 300)
          }
        })

        return 0
      }
    },
    [downloadImage, getBlobFromUrl],
  )

  /**
   * @function reprocessCompletedImages
   * @description Reprocesses completed images with a new background color
   */
  const reprocessCompletedImages = useCallback(() => {
    const completedJobs = imageListRef.current.filter(
      (job) => job.status === 'completed' && job.segmentationResult && job.preprocessedImageUrl,
    )

    if (completedJobs.length === 0) {
      console.log('[MainThread-BgCtrl] No completed jobs to reprocess')
      return
    }

    console.log(
      `[MainThread-BgCtrl] Reprocessing ${completedJobs.length} completed images with new background color`,
    )

    // Update job statuses to pending_postprocessing and clear processed URLs
    setImageList((prevList) =>
      prevList.map((job) => {
        if (job.status === 'completed' && job.segmentationResult && job.preprocessedImageUrl) {
          // Clean up the old processed image URL
          if (job.processedImageUrl && job.processedImageUrl.startsWith('blob:')) {
            URL.revokeObjectURL(job.processedImageUrl)
          }

          return {
            ...job,
            status: 'pending_postprocessing' as const,
            processedImageUrl: undefined,
            processedFileSize: undefined,
            error: undefined,
          }
        }
        return job
      }),
    )

    // Add jobs to postprocessing queue
    const jobIdsToReprocess = completedJobs.map((job) => job.id)
    postprocessingQueueRef.current = [
      ...new Set([...postprocessingQueueRef.current, ...jobIdsToReprocess]),
    ]

    // Start batch processing if not already active
    if (!isBatchActiveRef.current) {
      setIsBatchActive(true)
    }

    // Trigger postprocessing queue
    setTriggerMaskApplicationQueue((c) => c + 1)
  }, [setImageList, setIsBatchActive, setTriggerMaskApplicationQueue, postprocessingQueueRef])

  /**
   * @function clearAllJobs
   * @description Removes all jobs from the imageList and cancels any current processing
   */
  const clearAllJobs = useCallback(() => {
    // Cancel batch processing if active
    if (isBatchActiveRef.current) {
      setIsBatchActive(false)
    }

    // Clear all queues
    preprocessingQueueRef.current = []
    segmentationQueueRef.current = []
    postprocessingQueueRef.current = []

    // Revoke all blob URLs to prevent memory leaks
    imageListRef.current.forEach((job) => {
      if (job.originalBlobUrl) URL.revokeObjectURL(job.originalBlobUrl)
      if (job.processedImageUrl) URL.revokeObjectURL(job.processedImageUrl)
    })

    // Clear the image list
    setImageList([])
    setOverallError(null)
  }, [
    setIsBatchActive,
    setImageList,
    setOverallError,
    postprocessingQueueRef,
    preprocessingQueueRef,
    segmentationQueueRef,
  ])

  /**
   * @function removeJob
   * @description Removes a specific job from the imageList
   */
  const removeJob = useCallback(
    (jobId: string) => {
      const jobToRemove = imageListRef.current.find((job) => job.id === jobId)

      if (!jobToRemove) return

      // Remove from any processing queues
      preprocessingQueueRef.current = preprocessingQueueRef.current.filter((id) => id !== jobId)
      segmentationQueueRef.current = segmentationQueueRef.current.filter((id) => id !== jobId)
      postprocessingQueueRef.current = postprocessingQueueRef.current.filter((id) => id !== jobId)

      // Revoke blob URLs to prevent memory leaks
      if (jobToRemove.originalBlobUrl) URL.revokeObjectURL(jobToRemove.originalBlobUrl)
      if (jobToRemove.processedImageUrl) URL.revokeObjectURL(jobToRemove.processedImageUrl)

      // Remove from image list
      setImageList((prevList) => prevList.filter((job) => job.id !== jobId))
    },
    [setImageList, postprocessingQueueRef, segmentationQueueRef, preprocessingQueueRef],
  )

  // Derived state: Indicates if there are any jobs that are not yet completed or errored.
  const hasPendingOrQueuedJobs = imageList.some(
    (job) =>
      job.status === 'pending_preprocessing' ||
      job.status === 'pending_segmentation' ||
      job.status === 'queued' ||
      job.status === 'pending_postprocessing',
  )

  // Derived state: Counts of active jobs in each worker pool.
  const activePreprocessingJobCount = Array.from(
    preprocessingWorkerJobAssignments.current.values(),
  ).filter((j) => j !== null).length
  const activeSegmentationJobCount = Array.from(
    segmentationWorkerJobAssignments.current.values(),
  ).filter((j) => j !== null).length
  const activeMaskApplicationJobCount = Array.from(
    postprocessingWorkerJobAssignments.current.values(),
  ).filter((j) => j !== null).length

  // Derived state: Counts of enqueued jobs for each stage.
  const enqueuedPreprocessingJobCount = preprocessingQueueRef.current.length
  const enqueuedSegmentationJobCount = segmentationQueueRef.current.length
  const enqueuedMaskApplicationJobCount = postprocessingQueueRef.current.length

  // Derived state: Total count of jobs remaining (enqueued or actively being processed).
  const remainingJobCount =
    enqueuedPreprocessingJobCount +
    enqueuedSegmentationJobCount +
    enqueuedMaskApplicationJobCount +
    activePreprocessingJobCount +
    activeSegmentationJobCount +
    activeMaskApplicationJobCount

  const segWorkerInitStatus = segmentationWorkerInitializationStatus.current
  const allSegmentationWorkersScriptCreationFailed =
    initializationPhaseRef.current === 'all_initialized' &&
    segWorkerInitStatus.length > 0 &&
    segWorkerInitStatus.every((status) => status === 'failed')

  const isInitializingSegmentationWorkers =
    initializationPhaseRef.current !== 'all_initialized' &&
    initializationPhaseRef.current !== 'idle'

  // Values returned by the hook for use in components.
  return {
    modelLoading:
      modelLoading || // True if explicit model loading state is true
      (isInitializingSegmentationWorkers && // Also true if segmentation workers are initializing (implies model loading)
        !modelLoaded &&
        !allSegmentationWorkersScriptCreationFailed), // but not if all failed to init
    modelLoaded,
    imageList,
    overallError,
    isBatchActive,
    handleFileChange,
    handleStartBatchProcess,
    downloadImage,
    createAndDownloadZip,
    hasPendingOrQueuedJobs,
    remainingJobCount,
    clearAllJobs,
    removeJob,
    setImageList, // Expose setImageList to allow direct updates to imageList state
    segmentationController,
    webGLSupported,
    webGPUSupported,
    compatibilityChecked,
    backgroundColor,
    backgroundImageUrl,
    backgroundImageAlpha,
    reprocessCompletedImages,
  }
}
